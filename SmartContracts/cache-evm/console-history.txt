const tx = await nfpm.mint(params);
};
  deadline: Math.floor(Date.now()/1000) + 3600
  recipient: signer.address,
  amount0Min: 0, amount1Min: 0,
  amount0Desired: amt, amount1Desired: amt,
  tickLower, tickUpper,
  token0, token1, deployer,
const params = {
const deployer = await nfpm.poolDeployer();
const nfpm = new ethers.Contract(nfpmAddr, nfpmAbi, signer);
const deployer = await nfpm.poolDeployer();
const tickUpper = aligned + 2*spacing;
const tickLower = aligned - 2*spacing;
const aligned = Math.floor(curTick / spacing) * spacing;
const curTick = Number(gs.tick);
onst curTick = Number(gs.tick);
spacing = Number(await pool.tickSpacing()); 
const gs = await pool.globalState();   let spacing;
// Align ticks to tickSpacing around current tick
await (await t1.approve(nfpmAddr, ethers.MaxUint256)).wait();
await (await t0.approve(nfpmAddr, ethers.MaxUint256)).wait();
await (await t1.mint(signer.address, amt)).wait();
await (await t0.mint(signer.address, amt)).wait();
const amt = ethers.parseEther("5000");
// Prepare funds and approvals
const t1 = new ethers.Contract(token1, erc20Abi, signer);
const t0 = new ethers.Contract(token0, erc20Abi, signer);
const pool = new ethers.Contract(poolAddr, poolAbi, signer);
const nfpm = new ethers.Contract(nfpmAddr, nfpmAbi, signer);
];
  "function balanceOf(address) view returns (uint256)"
  "function mint(address to,uint256 amount) external",
  "function approve(address spender,uint256 value) external returns (bool)",
const erc20Abi = [
const poolAbi = require("./node_modules/@cryptoalgebra/integral-core/artifacts/contracts/AlgebraPool.sol/AlgebraPool.json").abi;
const nfpmAbi = require("./node_modules/@cryptoalgebra/integral-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json").abi;
// Attach contracts
if (token0.toLowerCase() > token1.toLowerCase()) { const t = token0; token0 = token1; token1 = t; }
// Enforce token0 < token1 by address
let token1 = test.token1;
let token0 = test.token0;
const poolAddr = test.pool;
const nfpmAddr = dep.contracts.nfpm;
const test = JSON.parse(fs.readFileSync("./deployments/test-pool-result.json","utf8"));
onst dep = JSON.parse(fs.readFileSync("./deployments/moonbase_algebra.json","utf8"));
const [signer] = await ethers.getSigners();
const path = require("path");
const fs = require("fs");
await (await tkn0.approve(nfpmAddr, ethers.MaxUint256)).wait();
await (await tkn0.approve(nfpmAddress, ethers.MaxUint256)).wait();
const tkn1 = await TestERC20.connect(token1Address);
const tkn0 = await TestERC20.connect(token0Address);
const TestERC20 = await ethers.getContractFactory("TestERC20");
const tickupper = Number(await pool.tickSpacing()) * 100; 
const ticklower = Number(await pool.tickSpacing()) * 60; 
const [token0Address, token1Address] = ["0x38b554C53d03544Ac3b9C3eE01F74b0A261D40C4","0xdFd5A2230438D45004Df49679442f536dEf3D3F2"]
(await pool.globalState())
(await pool.tickSpacing())
(await nfpm.poolDeployer())
(await nfpm.factory())
const pool = new ethers.Contract(poolAddr, poolArtifact.abi, signer);
const nfpm = new ethers.Contract(nfpmAddr, nfpmArtifact.abi, signer);
const poolArtifact = require("./node_modules/@cryptoalgebra/integral-core/artifacts/contracts/AlgebraPool.sol/AlgebraPool.json");
const nfpmArtifact = require("./node_modules/@cryptoalgebra/integral-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json");
const poolAddr = "0xBeDE8EF3039BDF59b4F6a669EAa92eAbd847091D";
const nfpmAddr = "0xaFBf1201b744729411CF5A1B2Bd7f846f0a6FC32"
const [signer] = await ethers.getSigners();